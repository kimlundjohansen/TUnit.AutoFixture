using AutoFixture;
using TUnit.AutoFixture.Internal;

namespace TUnit.AutoFixture;

/// <summary>
/// Combines explicit inline values with AutoFixture-generated parameters.
/// This attribute is compatible with xUnit's [InlineAutoData] naming convention.
/// Multiple instances of this attribute can be applied to create multiple test cases.
/// </summary>
/// <example>
/// Basic usage - explicit values followed by auto-generated:
/// <code>
/// [Test]
/// [InlineAutoData("John", 25)]
/// [InlineAutoData("Jane", 30)]
/// public void TestMethod(string name, int age, Address address)
/// {
///     // 'name' and 'age' use the explicit values ("John", 25) or ("Jane", 30)
///     // 'address' is automatically generated by AutoFixture
///     // This creates 2 test cases
/// }
/// </code>
/// </example>
/// <example>
/// Usage with frozen dependencies:
/// <code>
/// [Test]
/// [InlineAutoData(100)]
/// public void TestMethod(int explicitValue, [Frozen] Person person, Consumer consumer)
/// {
///     // explicitValue = 100 (explicit)
///     // person and consumer.Person are the same frozen instance (auto-generated)
/// }
/// </code>
/// </example>
[AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public class InlineAutoDataAttribute : AutoDataAttribute
{
    private readonly object?[] explicitValues;

    /// <summary>
    /// Initializes a new instance of the <see cref="InlineAutoDataAttribute"/> class
    /// with explicit values for the first N parameters.
    /// </summary>
    /// <param name="values">
    /// The explicit values to use for the first N parameters.
    /// Remaining parameters will be auto-generated by AutoFixture.
    /// </param>
    /// <example>
    /// <code>
    /// [InlineAutoData("test", 42)]
    /// public void Method(string text, int number, Person person)
    /// {
    ///     // text = "test" (explicit)
    ///     // number = 42 (explicit)
    ///     // person = auto-generated
    /// }
    /// </code>
    /// </example>
    public InlineAutoDataAttribute(params object?[] values)
    {
        this.explicitValues = values ?? [];
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="InlineAutoDataAttribute"/> class
    /// with a custom fixture factory and explicit values.
    /// </summary>
    /// <param name="fixtureFactory">
    /// A factory function that creates an IFixture instance.
    /// </param>
    /// <param name="values">
    /// The explicit values to use for the first N parameters.
    /// </param>
    protected InlineAutoDataAttribute(Func<IFixture> fixtureFactory, params object?[] values)
        : base(fixtureFactory)
    {
        this.explicitValues = values ?? [];
    }

    /// <summary>
    /// Generates test data combining explicit values with AutoFixture-generated values.
    /// </summary>
    /// <param name="dataGeneratorMetadata">
    /// Metadata about the test method and parameters.
    /// </param>
    /// <returns>
    /// An enumerable of functions that generate parameter arrays.
    /// Each function represents one test case.
    /// </returns>
    /// <exception cref="ArgumentException">
    /// Thrown when more explicit values are provided than the method has parameters.
    /// </exception>
    protected override IEnumerable<Func<object?[]>> GenerateDataSources(DataGeneratorMetadata dataGeneratorMetadata)
    {
        if (dataGeneratorMetadata is null)
        {
            throw new ArgumentNullException(nameof(dataGeneratorMetadata));
        }

        return this.GenerateDataSourcesIterator(dataGeneratorMetadata);
    }

    private IEnumerable<Func<object?[]>> GenerateDataSourcesIterator(DataGeneratorMetadata dataGeneratorMetadata)
    {
        var parameters = dataGeneratorMetadata.MembersToGenerate;

        // Validate that we don't have more explicit values than parameters
        if (this.explicitValues.Length > parameters.Length)
        {
            throw new ArgumentException(
                $"Provided {this.explicitValues.Length} explicit values but method has {parameters.Length} parameters. " +
                $"InlineAutoData cannot provide more values than the method accepts.",
                nameof(this.explicitValues));
        }

        // Return a single test case with hybrid values
        yield return () =>
        {
            var result = new object?[parameters.Length];

            // Copy explicit values to the beginning of the result array
            Array.Copy(this.explicitValues, result, this.explicitValues.Length);

            // Generate remaining parameters with AutoFixture if needed
            if (this.explicitValues.Length < parameters.Length)
            {
                var fixture = this.Fixture;
                var generator = new AutoFixtureDataGenerator(fixture);

                // Get only the parameters that need auto-generation
                var parametersToGenerate = parameters
                    .Skip(this.explicitValues.Length)
                    .ToArray();

                var autoGeneratedValues = generator.Generate(parametersToGenerate);

                // Copy auto-generated values to the remaining slots
                Array.Copy(
                    autoGeneratedValues,
                    0,
                    result,
                    this.explicitValues.Length,
                    autoGeneratedValues.Length);
            }

            return result;
        };
    }
}
